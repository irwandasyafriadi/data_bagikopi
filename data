Panduan Lengkap Java OOP untuk Mentoring UAS
Studi Kasus Utama: Sistem Manajemen Perpustakaan Digital
Kita akan menggunakan sistem perpustakaan sebagai studi kasus yang konsisten untuk menerapkan semua konsep OOP.

1. ENKAPSULASI (Encapsulation)
Konsep Dasar
Enkapsulasi adalah prinsip menyembunyikan detail implementasi internal dan hanya mengekspos interface yang diperlukan melalui method public.

Implementasi Dasar
java
// Class Book dengan enkapsulasi
public class Book {
    private String isbn;           // Data disembunyikan
    private String title;
    private String author;
    private double price;
    private boolean isAvailable;
    
    // Constructor
    public Book(String isbn, String title, String author, double price) {
        this.isbn = isbn;
        this.title = title;
        this.author = author;
        setPrice(price);  // Menggunakan setter untuk validasi
        this.isAvailable = true;
    }
    
    // Getter methods
    public String getIsbn() { return isbn; }
    public String getTitle() { return title; }
    public String getAuthor() { return author; }
    public double getPrice() { return price; }
    public boolean isAvailable() { return isAvailable; }
    
    // Setter methods dengan validasi
    public void setPrice(double price) {
        if (price >= 0) {
            this.price = price;
        } else {
            throw new IllegalArgumentException("Harga tidak boleh negatif");
        }
    }
    
    public void setTitle(String title) {
        if (title != null && !title.trim().isEmpty()) {
            this.title = title;
        }
    }
    
    // Business methods
    public void borrowBook() {
        if (isAvailable) {
            isAvailable = false;
        } else {
            throw new RuntimeException("Buku sedang dipinjam");
        }
    }
    
    public void returnBook() {
        isAvailable = true;
    }
    
    @Override
    public String toString() {
        return String.format("Book[ISBN=%s, Title=%s, Author=%s, Price=%.2f, Available=%s]", 
                           isbn, title, author, price, isAvailable);
    }
}
Keuntungan Enkapsulasi
Data Protection: Data internal terlindungi dari akses langsung
Validation: Dapat menambahkan validasi di setter
Maintenance: Mudah mengubah implementasi internal tanpa mempengaruhi kode lain
2. INHERITANCE (Pewarisan)
Konsep Dasar
Inheritance memungkinkan class child mewarisi properties dan methods dari class parent, mendukung reusability dan hierarki class.

Implementasi dengan Studi Kasus
java
// Base class
public abstract class LibraryItem {
    protected String id;
    protected String title;
    protected boolean isAvailable;
    protected String category;
    
    public LibraryItem(String id, String title, String category) {
        this.id = id;
        this.title = title;
        this.category = category;
        this.isAvailable = true;
    }
    
    // Abstract method - harus diimplementasi child class
    public abstract double calculateLateFee(int daysLate);
    
    // Concrete methods yang bisa diwarisi
    public void borrow() {
        if (isAvailable) {
            isAvailable = false;
            System.out.println(title + " berhasil dipinjam");
        } else {
            System.out.println(title + " sedang tidak tersedia");
        }
    }
    
    public void returnItem() {
        isAvailable = true;
        System.out.println(title + " berhasil dikembalikan");
    }
    
    // Getters
    public String getId() { return id; }
    public String getTitle() { return title; }
    public boolean isAvailable() { return isAvailable; }
    public String getCategory() { return category; }
}

// Child class 1: Book
public class Book extends LibraryItem {
    private String author;
    private String isbn;
    private int pages;
    
    public Book(String id, String title, String author, String isbn, int pages) {
        super(id, title, "Book");  // Memanggil constructor parent
        this.author = author;
        this.isbn = isbn;
        this.pages = pages;
    }
    
    // Implementasi abstract method dari parent
    @Override
    public double calculateLateFee(int daysLate) {
        return daysLate * 1000; // Rp 1000 per hari untuk buku
    }
    
    // Method khusus untuk Book
    public void displayBookInfo() {
        System.out.printf("Buku: %s oleh %s (%d halaman)%n", title, author, pages);
    }
    
    // Getters khusus Book
    public String getAuthor() { return author; }
    public String getIsbn() { return isbn; }
    public int getPages() { return pages; }
}

// Child class 2: DVD
public class DVD extends LibraryItem {
    private String director;
    private int duration; // dalam menit
    private String genre;
    
    public DVD(String id, String title, String director, int duration, String genre) {
        super(id, title, "DVD");
        this.director = director;
        this.duration = duration;
        this.genre = genre;
    }
    
    @Override
    public double calculateLateFee(int daysLate) {
        return daysLate * 2000; // Rp 2000 per hari untuk DVD
    }
    
    public void displayDVDInfo() {
        System.out.printf("DVD: %s - %s (%d menit, %s)%n", 
                         title, director, duration, genre);
    }
    
    public String getDirector() { return director; }
    public int getDuration() { return duration; }
    public String getGenre() { return genre; }
}

// Child class 3: Magazine
public class Magazine extends LibraryItem {
    private String publisher;
    private int issueNumber;
    private String publishDate;
    
    public Magazine(String id, String title, String publisher, int issueNumber, String publishDate) {
        super(id, title, "Magazine");
        this.publisher = publisher;
        this.issueNumber = issueNumber;
        this.publishDate = publishDate;
    }
    
    @Override
    public double calculateLateFee(int daysLate) {
        return daysLate * 500; // Rp 500 per hari untuk majalah
    }
    
    public void displayMagazineInfo() {
        System.out.printf("Majalah: %s #%d oleh %s (%s)%n", 
                         title, issueNumber, publisher, publishDate);
    }
    
    public String getPublisher() { return publisher; }
    public int getIssueNumber() { return issueNumber; }
    public String getPublishDate() { return publishDate; }
}
3. POLIMORFISME (Polymorphism)
Konsep Dasar
Polimorfisme memungkinkan object dari class yang berbeda untuk ditreat sebagai instance dari class yang sama melalui interface atau inheritance.

Implementasi
java
// Interface untuk polymorphism
public interface Searchable {
    boolean matches(String keyword);
    String getSearchableContent();
}

// Interface untuk displayable items
public interface Displayable {
    void displayDetails();
}

// Mengimplementasi interfaces pada class
public class Book extends LibraryItem implements Searchable, Displayable {
    // ... kode sebelumnya ...
    
    @Override
    public boolean matches(String keyword) {
        keyword = keyword.toLowerCase();
        return title.toLowerCase().contains(keyword) || 
               author.toLowerCase().contains(keyword) ||
               isbn.contains(keyword);
    }
    
    @Override
    public String getSearchableContent() {
        return title + " " + author + " " + isbn;
    }
    
    @Override
    public void displayDetails() {
        System.out.printf("=== DETAIL BUKU ===%n");
        System.out.printf("ID: %s%n", id);
        System.out.printf("Judul: %s%n", title);
        System.out.printf("Penulis: %s%n", author);
        System.out.printf("ISBN: %s%n", isbn);
        System.out.printf("Halaman: %d%n", pages);
        System.out.printf("Status: %s%n", isAvailable ? "Tersedia" : "Dipinjam");
    }
}

public class DVD extends LibraryItem implements Searchable, Displayable {
    // ... kode sebelumnya ...
    
    @Override
    public boolean matches(String keyword) {
        keyword = keyword.toLowerCase();
        return title.toLowerCase().contains(keyword) || 
               director.toLowerCase().contains(keyword) ||
               genre.toLowerCase().contains(keyword);
    }
    
    @Override
    public String getSearchableContent() {
        return title + " " + director + " " + genre;
    }
    
    @Override
    public void displayDetails() {
        System.out.printf("=== DETAIL DVD ===%n");
        System.out.printf("ID: %s%n", id);
        System.out.printf("Judul: %s%n", title);
        System.out.printf("Sutradara: %s%n", director);
        System.out.printf("Durasi: %d menit%n", duration);
        System.out.printf("Genre: %s%n", genre);
        System.out.printf("Status: %s%n", isAvailable ? "Tersedia" : "Dipinjam");
    }
}

// Class untuk mendemonstrasikan polymorphism
public class LibraryManager {
    private List<LibraryItem> items;
    
    public LibraryManager() {
        items = new ArrayList<>();
    }
    
    public void addItem(LibraryItem item) {
        items.add(item);
    }
    
    // Polymorphism: method yang sama untuk semua jenis LibraryItem
    public void displayAllItems() {
        for (LibraryItem item : items) {
            if (item instanceof Displayable) {
                ((Displayable) item).displayDetails(); // Runtime polymorphism
            }
            System.out.println();
        }
    }
    
    // Method overloading (Compile-time polymorphism)
    public List<LibraryItem> search(String keyword) {
        return search(keyword, null);
    }
    
    public List<LibraryItem> search(String keyword, String category) {
        List<LibraryItem> results = new ArrayList<>();
        
        for (LibraryItem item : items) {
            if (item instanceof Searchable) {
                Searchable searchableItem = (Searchable) item;
                if (searchableItem.matches(keyword)) {
                    if (category == null || item.getCategory().equals(category)) {
                        results.add(item);
                    }
                }
            }
        }
        return results;
    }
    
    // Demonstrasi polymorphism dengan late fee calculation
    public void calculateAllLateFees(int daysLate) {
        System.out.println("=== PERHITUNGAN DENDA ===");
        for (LibraryItem item : items) {
            if (!item.isAvailable()) {
                double fee = item.calculateLateFee(daysLate); // Polymorphic call
                System.out.printf("%s: Rp %.0f%n", item.getTitle(), fee);
            }
        }
    }
}
4. STATIC & FINAL VARIABLE
Konsep Dasar
Static: Milik class, bukan instance. Shared oleh semua object.
Final: Konstanta yang tidak bisa diubah setelah inisialisasi.
Implementasi
java
public class LibraryConfig {
    // Final static constants
    public static final String LIBRARY_NAME = "Perpustakaan Digital Universitas";
    public static final int MAX_BORROW_DAYS = 14;
    public static final int MAX_BOOKS_PER_USER = 5;
    public static final double DEFAULT_LATE_FEE_RATE = 1000.0;
    
    // Static variables
    private static int totalItemsCreated = 0;
    private static int totalBorrowTransactions = 0;
    private static LibraryConfig instance; // Singleton pattern
    
    // Final instance variable
    private final String libraryId;
    
    // Private constructor untuk singleton
    private LibraryConfig() {
        this.libraryId = generateLibraryId();
    }
    
    // Static method untuk singleton
    public static LibraryConfig getInstance() {
        if (instance == null) {
            instance = new LibraryConfig();
        }
        return instance;
    }
    
    // Static methods
    public static void incrementItemCount() {
        totalItemsCreated++;
    }
    
    public static void recordBorrowTransaction() {
        totalBorrowTransactions++;
    }
    
    public static int getTotalItemsCreated() {
        return totalItemsCreated;
    }
    
    public static int getTotalBorrowTransactions() {
        return totalBorrowTransactions;
    }
    
    public static void displayLibraryStats() {
        System.out.println("=== STATISTIK PERPUSTAKAAN ===");
        System.out.printf("Nama: %s%n", LIBRARY_NAME);
        System.out.printf("Total Item Dibuat: %d%n", totalItemsCreated);
        System.out.printf("Total Transaksi Peminjaman: %d%n", totalBorrowTransactions);
        System.out.printf("Maksimal Hari Pinjam: %d hari%n", MAX_BORROW_DAYS);
        System.out.printf("Maksimal Buku per User: %d%n", MAX_BOOKS_PER_USER);
    }
    
    // Static utility methods
    public static boolean isValidISBN(String isbn) {
        return isbn != null && isbn.matches("\\d{10}|\\d{13}");
    }
    
    public static String formatPrice(double price) {
        return String.format("Rp %.2f", price);
    }
    
    private String generateLibraryId() {
        return "LIB-" + System.currentTimeMillis();
    }
    
    public String getLibraryId() {
        return libraryId;
    }
}

// Modified LibraryItem untuk menggunakan static
public abstract class LibraryItem {
    protected String id;
    protected String title;
    protected boolean isAvailable;
    protected String category;
    
    // Static counter untuk auto-generate ID
    private static int itemCounter = 1;
    
    public LibraryItem(String title, String category) {
        this.id = generateId();
        this.title = title;
        this.category = category;
        this.isAvailable = true;
        
        // Increment static counter
        LibraryConfig.incrementItemCount();
    }
    
    private static String generateId() {
        return String.format("ITEM-%04d", itemCounter++);
    }
    
    public void borrow() {
        if (isAvailable) {
            isAvailable = false;
            LibraryConfig.recordBorrowTransaction(); // Static method call
            System.out.println(title + " berhasil dipinjam");
        } else {
            System.out.println(title + " sedang tidak tersedia");
        }
    }
    
    // Abstract method
    public abstract double calculateLateFee(int daysLate);
    
    // Method menggunakan static constant
    public boolean isOverdue(int daysBorrowed) {
        return daysBorrowed > LibraryConfig.MAX_BORROW_DAYS;
    }
}
5. EXCEPTION HANDLING
Konsep Dasar
Exception handling memungkinkan program menangani error dengan graceful tanpa crash.

Custom Exceptions
java
// Custom exceptions untuk perpustakaan
public class LibraryException extends Exception {
    public LibraryException(String message) {
        super(message);
    }
    
    public LibraryException(String message, Throwable cause) {
        super(message, cause);
    }
}

public class ItemNotAvailableException extends LibraryException {
    public ItemNotAvailableException(String itemTitle) {
        super("Item '" + itemTitle + "' sedang tidak tersedia untuk dipinjam");
    }
}

public class BorrowLimitExceededException extends LibraryException {
    public BorrowLimitExceededException(int currentCount, int maxLimit) {
        super(String.format("Batas peminjaman terlampaui: %d/%d", currentCount, maxLimit));
    }
}

public class InvalidItemDataException extends LibraryException {
    public InvalidItemDataException(String field, String value) {
        super(String.format("Data tidak valid untuk field '%s': %s", field, value));
    }
}
Implementasi Exception Handling
java
public class User {
    private String userId;
    private String name;
    private String email;
    private List<LibraryItem> borrowedItems;
    
    public User(String userId, String name, String email) throws InvalidItemDataException {
        validateUserData(userId, name, email);
        this.userId = userId;
        this.name = name;
        this.email = email;
        this.borrowedItems = new ArrayList<>();
    }
    
    private void validateUserData(String userId, String name, String email) 
            throws InvalidItemDataException {
        if (userId == null || userId.trim().isEmpty()) {
            throw new InvalidItemDataException("userId", userId);
        }
        if (name == null || name.trim().isEmpty()) {
            throw new InvalidItemDataException("name", name);
        }
        if (email == null || !email.contains("@")) {
            throw new InvalidItemDataException("email", email);
        }
    }
    
    public void borrowItem(LibraryItem item) 
            throws ItemNotAvailableException, BorrowLimitExceededException {
        
        // Check availability
        if (!item.isAvailable()) {
            throw new ItemNotAvailableException(item.getTitle());
        }
        
        // Check borrow limit
        if (borrowedItems.size() >= LibraryConfig.MAX_BOOKS_PER_USER) {
            throw new BorrowLimitExceededException(
                borrowedItems.size(), LibraryConfig.MAX_BOOKS_PER_USER);
        }
        
        // Proceed with borrowing
        item.borrow();
        borrowedItems.add(item);
        System.out.printf("User %s berhasil meminjam: %s%n", name, item.getTitle());
    }
    
    public void returnItem(LibraryItem item) {
        try {
            if (borrowedItems.remove(item)) {
                item.returnItem();
                System.out.printf("User %s berhasil mengembalikan: %s%n", 
                                name, item.getTitle());
            } else {
                System.out.printf("User %s tidak meminjam item: %s%n", 
                                name, item.getTitle());
            }
        } catch (Exception e) {
            System.err.println("Error saat mengembalikan item: " + e.getMessage());
        }
    }
    
    public List<LibraryItem> getBorrowedItems() {
        return new ArrayList<>(borrowedItems); // Defensive copy
    }
    
    // Getters
    public String getUserId() { return userId; }
    public String getName() { return name; }
    public String getEmail() { return email; }
}

// Library service dengan comprehensive exception handling
public class LibraryService {
    private List<LibraryItem> items;
    private List<User> users;
    
    public LibraryService() {
        items = new ArrayList<>();
        users = new ArrayList<>();
    }
    
    public void addItem(LibraryItem item) {
        try {
            if (item == null) {
                throw new IllegalArgumentException("Item tidak boleh null");
            }
            items.add(item);
            System.out.println("Item berhasil ditambahkan: " + item.getTitle());
        } catch (Exception e) {
            System.err.println("Error menambahkan item: " + e.getMessage());
        }
    }
    
    public void registerUser(String userId, String name, String email) {
        try {
            User user = new User(userId, name, email);
            users.add(user);
            System.out.println("User berhasil didaftarkan: " + name);
        } catch (InvalidItemDataException e) {
            System.err.println("Gagal mendaftarkan user: " + e.getMessage());
        } catch (Exception e) {
            System.err.println("Error tidak terduga: " + e.getMessage());
        }
    }
    
    public void processBorrowRequest(String userId, String itemId) {
        try {
            User user = findUserById(userId);
            LibraryItem item = findItemById(itemId);
            
            user.borrowItem(item);
            
        } catch (ItemNotAvailableException | BorrowLimitExceededException e) {
            System.err.println("Peminjaman gagal: " + e.getMessage());
        } catch (RuntimeException e) {
            System.err.println("User atau item tidak ditemukan: " + e.getMessage());
        } catch (Exception e) {
            System.err.println("Error tidak terduga: " + e.getMessage());
            e.printStackTrace();
        }
    }
    
    private User findUserById(String userId) {
        return users.stream()
                   .filter(user -> user.getUserId().equals(userId))
                   .findFirst()
                   .orElseThrow(() -> new RuntimeException("User tidak ditemukan: " + userId));
    }
    
    private LibraryItem findItemById(String itemId) {
        return items.stream()
                   .filter(item -> item.getId().equals(itemId))
                   .findFirst()
                   .orElseThrow(() -> new RuntimeException("Item tidak ditemukan: " + itemId));
    }
    
    // Method dengan multiple exception types
    public void processReturnWithLateFee(String userId, String itemId, int daysLate) {
        User user = null;
        LibraryItem item = null;
        
        try {
            user = findUserById(userId);
            item = findItemById(itemId);
            
            // Calculate late fee
            double lateFee = 0;
            if (daysLate > 0) {
                lateFee = item.calculateLateFee(daysLate);
                System.out.printf("Denda keterlambatan: %s%n", 
                                LibraryConfig.formatPrice(lateFee));
            }
            
            user.returnItem(item);
            
        } catch (RuntimeException e) {
            System.err.println("Data tidak ditemukan: " + e.getMessage());
        } catch (ArithmeticException e) {
            System.err.println("Error perhitungan denda: " + e.getMessage());
        } catch (Exception e) {
            System.err.println("Error tidak terduga saat pengembalian: " + e.getMessage());
        } finally {
            // Cleanup or logging
            System.out.println("Proses pengembalian selesai dieksekusi");
        }
    }
}
6. ABSTRACT CLASS DAN INTERFACE
Konsep Dasar
Abstract Class: Class yang tidak bisa diinstansiasi, berisi method abstract dan concrete
Interface: Kontrak yang mendefinisikan method yang harus diimplementasi
Implementasi Lanjutan
java
// Abstract class untuk reporting system
public abstract class ReportGenerator {
    protected String reportTitle;
    protected String generatedBy;
    protected Date generatedDate;
    
    public ReportGenerator(String reportTitle, String generatedBy) {
        this.reportTitle = reportTitle;
        this.generatedBy = generatedBy;
        this.generatedDate = new Date();
    }
    
    // Template method pattern
    public final void generateReport() {
        printHeader();
        printBody();
        printFooter();
        saveReport();
    }
    
    // Concrete methods
    protected void printHeader() {
        System.out.println("=" .repeat(50));
        System.out.println(reportTitle.toUpperCase());
        System.out.println("Generated by: " + generatedBy);
        System.out.println("Date: " + generatedDate);
        System.out.println("=" .repeat(50));
    }
    
    protected void printFooter() {
        System.out.println("=" .repeat(50));
        System.out.println("End of Report");
    }
    
    // Abstract methods - must be implemented by subclasses
    protected abstract void printBody();
    protected abstract void saveReport();
    protected abstract String getReportFormat();
}

// Multiple interfaces untuk different behaviors
public interface Exportable {
    void exportToCSV(String filename);
    void exportToPDF(String filename);
    boolean isExportable();
}

public interface Printable {
    void print();
    void printPreview();
    int getPageCount();
}

public interface Schedulable {
    void scheduleGeneration(String cronExpression);
    void cancelSchedule();
    boolean isScheduled();
}

// Concrete implementation
public class LibraryUsageReport extends ReportGenerator 
        implements Exportable, Printable, Schedulable {
    
    private List<LibraryItem> items;
    private List<User> users;
    private boolean scheduled;
    
    public LibraryUsageReport(String generatedBy, List<LibraryItem> items, List<User> users) {
        super("Library Usage Report", generatedBy);
        this.items = items;
        this.users = users;
        this.scheduled = false;
    }
    
    @Override
    protected void printBody() {
        System.out.println("\n--- STATISTIK PENGGUNAAN ---");
        System.out.printf("Total Items: %d%n", items.size());
        System.out.printf("Total Users: %d%n", users.size());
        
        // Available vs borrowed items
        long availableItems = items.stream().mapToLong(item -> item.isAvailable() ? 1 : 0).sum();
        long borrowedItems = items.size() - availableItems;
        
        System.out.printf("Available Items: %d%n", availableItems);
        System.out.printf("Borrowed Items: %d%n", borrowedItems);
        
        // Items by category
        Map<String, Long> itemsByCategory = items.stream()
            .collect(Collectors.groupingBy(LibraryItem::getCategory, Collectors.counting()));
        
        System.out.println("\n--- ITEMS BY CATEGORY ---");
        itemsByCategory.forEach((category, count) -> 
            System.out.printf("%s: %d items%n", category, count));
        
        // Most active users
        System.out.println("\n--- ACTIVE USERS ---");
        users.stream()
             .sorted((u1, u2) -> Integer.compare(u2.getBorrowedItems().size(), u1.getBorrowedItems().size()))
             .limit(5)
             .forEach(user -> System.out.printf("%s: %d items borrowed%n", 
                                              user.getName(), user.getBorrowedItems().size()));
    }
    
    @Override
    protected void saveReport() {
        System.out.println("\n[INFO] Report saved to database");
    }
    
    @Override
    protected String getReportFormat() {
        return "TXT";
    }
    
    // Implementing Exportable
    @Override
    public void exportToCSV(String filename) {
        System.out.printf("Exporting report to CSV: %s%n", filename);
        // Implementation would write CSV data
    }
    
    @Override
    public void exportToPDF(String filename) {
        System.out.printf("Exporting report to PDF: %s%n", filename);
        // Implementation would generate PDF
    }
    
    @Override
    public boolean isExportable() {
        return items != null && users != null;
    }
    
    // Implementing Printable
    @Override
    public void print() {
        System.out.println("Printing report to default printer...");
        generateReport();
    }
    
    @Override
    public void printPreview() {
        System.out.println("=== PRINT PREVIEW ===");
        generateReport();
    }
    
    @Override
    public int getPageCount() {
        return Math.max(1, (items.size() + users.size()) / 20); // Estimate
    }
    
    // Implementing Schedulable
    @Override
    public void scheduleGeneration(String cronExpression) {
        System.out.printf("Report scheduled with expression: %s%n", cronExpression);
        scheduled = true;
    }
    
    @Override
    public void cancelSchedule() {
        System.out.println("Report schedule cancelled");
        scheduled = false;
    }
    
    @Override
    public boolean isScheduled() {
        return scheduled;
    }
}

// Another concrete implementation
public class InventoryReport extends ReportGenerator implements Exportable {
    private List<LibraryItem> items;
    
    public InventoryReport(String generatedBy, List<LibraryItem> items) {
        super("Library Inventory Report", generatedBy);
        this.items = items;
    }
    
    @Override
    protected void printBody() {
        System.out.println("\n--- INVENTORY DETAILS ---");
        Map<String, List<LibraryItem>> itemsByCategory = items.stream()
            .collect(Collectors.groupingBy(LibraryItem::getCategory));
        
        itemsByCategory.forEach((category, categoryItems) -> {
            System.out.printf("\n%s (%d items):%n", category, categoryItems.size());
            categoryItems.forEach(item -> 
                System.out.printf("  - %s [%s] %s%n", 
                                item.getTitle(), 
                                item.getId(), 
                                item.isAvailable() ? "Available" : "Borrowed"));
        });
    }
    
    @Override
    protected void saveReport() {
        System.out.println("\n[INFO] Inventory report archived");
    }
    
    @Override
    protected String getReportFormat() {
        return "PDF";
    }
    
    @Override
    public void exportToCSV(String filename) {
        System.out.printf("Exporting inventory to CSV: %s%n", filename);
    }
    
    @Override
    public void exportToPDF(String filename) {
        System.out.printf("Exporting inventory to PDF: %s%n", filename);
    }
    
    @Override
    public boolean isExportable() {
        return items != null && !items.isEmpty();
    }
}
7. JAVA COLLECTION
Konsep Dasar
Java Collections menyediakan struktur data yang powerful untuk menyimpan dan memanipulasi grup objek.

Implementasi dengan Studi Kasus
java
import java.util.*;
import java.util.stream.Collectors;

public class LibraryDatabase {
    // List - untuk ordered collection, allows duplicates
    private List<LibraryItem> allItems;
    private List<User> registeredUsers;
    private List<BorrowTransaction> borrowHistory;
    
    // Set - untuk unique collections
    private Set<String> isbnNumbers;
    private Set<String> userEmails;
    
    // Map - untuk key-value associations
    private Map<String, LibraryItem> itemsById;
    private Map<String, User> usersById;
    private Map<String, List<LibraryItem>> itemsByCategory;
    private Map<User, List<LibraryItem>> userBorrowedItems;
    
    // Queue - untuk processing queues
    private Queue<BorrowRequest> pendingRequests;
    private PriorityQueue<LibraryItem> popularItems;
    
    public LibraryDatabase() {
        // Initialize collections
        allItems = new ArrayList<>();
        registeredUsers = new LinkedList<>(); // LinkedList untuk frequent insertions
        borrowHistory = new ArrayList<>();
        
        isbnNumbers = new HashSet<>();
        userEmails = new TreeSet<>(); // TreeSet untuk sorted emails
        
        itemsById = new HashMap<>();
        usersById = new LinkedHashMap<>(); // LinkedHashMap untuk insertion order
        itemsByCategory = new TreeMap<>(); // TreeMap untuk sorted categories
        userBorrowedItems = new HashMap<>();
        
        pendingRequests = new LinkedList<>();
        popularItems = new PriorityQueue<>((item1, item2) -> 
            Integer.compare(getPopularityScore(item2), getPopularityScore(item1)));
    }
    
    // Methods untuk List operations
    public void addItem(LibraryItem item) {
        allItems.add(item);
        itemsById.put(item.getId(), item);
        
        // Add to category map
        itemsByCategory.computeIfAbsent(item.getCategory(), k -> new ArrayList<>()).add(item);
        
        // Add ISBN if it's a book
        if (item instanceof Book) {
            Book book = (Book) item;
            isbnNumbers.add(book.getIsbn());
        }
        
        System.out.printf("Item added: %s (Total items: %d)%n", item.getTitle(), allItems.size());
    }
    
    public void registerUser(User user) throws InvalidItemDataException {
        // Check for duplicate email using Set
        if (userEmails.contains(user.getEmail())) {
            throw new InvalidItemDataException("email", "Email already registered: " + user.getEmail());
        }
        
        registeredUsers.add(user);
        usersById.put(user.getUserId(), user);
        userEmails.add(user.getEmail());
        userBorrowedItems.put(user, new ArrayList<>());
        
        System.out.printf("User registered: %s (Total users: %d)%n", user.getName(), registeredUsers.size());
    }
    
    // Collection operations dengan Streams
    public List<LibraryItem> searchItems(String keyword) {
        return allItems.stream()
                      .filter(item -> item instanceof Searchable)
                      .map(item -> (Searchable) item)
                      .filter(searchable -> searchable.matches(keyword))
                      .map(searchable -> (LibraryItem) searchable)
                      .collect(Collectors.toList());
    }
    
    public List<LibraryItem> getAvailableItems() {
        return allItems.stream()
                      .filter(LibraryItem::isAvailable)
                      .collect(Collectors.toList());
    }
    
    public List<LibraryItem> getItemsByCategory(String category) {
        return itemsByCategory.getOrDefault(category, new ArrayList<>());
    }
    
    public Map<String, Long> getCategoryStatistics() {
        return allItems.stream()
                      .collect(Collectors.groupingBy(
                          LibraryItem::getCategory, 
                          Collectors.counting()));
    }
    
    // Queue operations untuk borrow requests
    public void addBorrowRequest(BorrowRequest request) {
        pendingRequests.offer(request);
        System.out.printf("Borrow request queued: %s wants %s%n", 
                         request.getUserId(), request.getItemId());
    }
    
    public BorrowRequest getNextBorrowRequest() {
        return pendingRequests.poll();
    }
    
    public int getPendingRequestsCount() {
        return pendingRequests.size();
    }
    
    // Process pending requests
    public void processPendingRequests() {
        System.out.println("Processing pending borrow requests...");
        
        while (!pendingRequests.isEmpty()) {
            BorrowRequest request = pendingRequests.poll();
            try {
                User user = usersById.get(request.getUserId());
                LibraryItem item = itemsById.get(request.getItemId());
                
                if (user != null && item != null && item.isAvailable()) {
                    user.borrowItem(item);
                    userBorrowedItems.get(user).add(item);
                    
                    // Record transaction
                    BorrowTransaction transaction = new BorrowTransaction(user, item, new Date());
                    borrowHistory.add(transaction);
                    
                    System.out.printf("✓ Processed: %s borrowed %s%n", 
                                     user.getName(), item.getTitle());
                } else {
                    System.out.printf("✗ Failed: Invalid request for %s%n", request.getItemId());
                }
            } catch (Exception e) {
                System.err.printf("Error processing request: %s%n", e.getMessage());
            }
        }
    }
    
    // Advanced collection operations
    public List<User> getMostActiveUsers(int limit) {
        return registeredUsers.stream()
                             .sorted((u1, u2) -> Integer.compare(
                                 userBorrowedItems.get(u2).size(), 
                                 userBorrowedItems.get(u1).size()))
                             .limit(limit)
                             .collect(Collectors.toList());
    }
    
    public Map<String, List<User>> getUsersByBorrowCount() {
        return registeredUsers.stream()
                             .collect(Collectors.groupingBy(user -> {
                                 int count = userBorrowedItems.get(user).size();
                                 if (count == 0) return "No Borrows";
                                 if (count <= 2) return "Light User";
                                 if (count <= 5) return "Regular User";
                                 return "Heavy User";
                             }));
    }
    
    // Iterator examples
    public void displayAllItems() {
        System.out.println("=== ALL LIBRARY ITEMS ===");
        Iterator<LibraryItem> iterator = allItems.iterator();
        int index = 1;
        
        while (iterator.hasNext()) {
            LibraryItem item = iterator.next();
            System.out.printf("%d. %s [%s] - %s%n", 
                             index++, item.getTitle(), item.getCategory(),
                             item.isAvailable() ? "Available" : "Borrowed");
        }
    }
    
    public void displayUsersByCategory() {
        System.out.println("=== USERS BY ACTIVITY LEVEL ===");
        Map<String, List<User>> userCategories = getUsersByBorrowCount();
        
        for (Map.Entry<String, List<User>> entry : userCategories.entrySet()) {
            System.out.printf("\n%s (%d users):%n", entry.getKey(), entry.getValue().size());
            for (User user : entry.getValue()) {
                System.out.printf("  - %s (%d items)%n", 
                                 user.getName(), userBorrowedItems.get(user).size());
            }
        }
    }
    
    // Helper methods
    private int getPopularityScore(LibraryItem item) {
        return (int) borrowHistory.stream()
                                 .filter(transaction -> transaction.getItem().equals(item))
                                 .count();
    }
    
    // Getters untuk collections
    public List<LibraryItem> getAllItems() {
        return new ArrayList<>(allItems); // Defensive copy
    }
    
    public List<User> getAllUsers() {
        return new ArrayList<>(registeredUsers);
    }
    
    public Set<String> getAllCategories() {
        return new TreeSet<>(itemsByCategory.keySet());
    }
    
    public List<BorrowTransaction> getBorrowHistory() {
        return new ArrayList<>(borrowHistory);
    }
}

// Support classes untuk collections
class BorrowRequest {
    private String userId;
    private String itemId;
    private Date requestDate;
    private Priority priority;
    
    public enum Priority { LOW, NORMAL, HIGH, URGENT }
    
    public BorrowRequest(String userId, String itemId, Priority priority) {
        this.userId = userId;
        this.itemId = itemId;
        this.priority = priority;
        this.requestDate = new Date();
    }
    
    // Getters
    public String getUserId() { return userId; }
    public String getItemId() { return itemId; }
    public Date getRequestDate() { return requestDate; }
    public Priority getPriority() { return priority; }
}

class BorrowTransaction {
    private User user;
    private LibraryItem item;
    private Date borrowDate;
    private Date returnDate;
    
    public BorrowTransaction(User user, LibraryItem item, Date borrowDate) {
        this.user = user;
        this.item = item;
        this.borrowDate = borrowDate;
    }
    
    public void setReturnDate(Date returnDate) {
        this.returnDate = returnDate;
    }
    
    public boolean isReturned() {
        return returnDate != null;
    }
    
    public long getDaysBorrowed() {
        Date endDate = returnDate != null ? returnDate : new Date();
        return (endDate.getTime() - borrowDate.getTime()) / (1000 * 60 * 60 * 24);
    }
    
    // Getters
    public User getUser() { return user; }
    public LibraryItem getItem() { return item; }
    public Date getBorrowDate() { return borrowDate; }
    public Date getReturnDate() { return returnDate; }
}
8. GUI + STUDI KASUS IMPLEMENTASI
Konsep Dasar
GUI (Graphical User Interface) dengan Swing untuk membuat aplikasi desktop yang user-friendly.

Implementasi GUI untuk Sistem Perpustakaan
java
import javax.swing.*;
import javax.swing.table.DefaultTableModel;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.List;

public class LibraryManagementGUI extends JFrame {
    private LibraryDatabase database;
    private LibraryService libraryService;
    
    // GUI Components
    private JTabbedPane tabbedPane;
    private JTable itemsTable;
    private JTable usersTable;
    private DefaultTableModel itemsTableModel;
    private DefaultTableModel usersTableModel;
    
    // Input fields
    private JTextField titleField, authorField, isbnField;
    private JTextField userNameField, userIdField, userEmailField;
    private JTextField searchField;
    private JComboBox<String> categoryComboBox;
    private JTextArea outputArea;
    
    public LibraryManagementGUI() {
        database = new LibraryDatabase();
        libraryService = new LibraryService();
        
        initializeGUI();
        setupEventListeners();
        loadSampleData();
    }
    
    private void initializeGUI() {
        setTitle("Library Management System - " + LibraryConfig.LIBRARY_NAME);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        setLayout(new BorderLayout());
        
        // Create tabbed pane
        tabbedPane = new JTabbedPane();
        
        // Create tabs
        tabbedPane.addTab("Items Management", createItemsPanel());
        tabbedPane.addTab("Users Management", createUsersPanel());
        tabbedPane.addTab("Borrow/Return", createBorrowReturnPanel());
        tabbedPane.addTab("Reports", createReportsPanel());
        
        add(tabbedPane, BorderLayout.CENTER);
        
        // Status bar
        JLabel statusBar = new JLabel("Ready");
        statusBar.setBorder(BorderFactory.createLoweredBevelBorder());
        add(statusBar, BorderLayout.SOUTH);
        
        // Menu bar
        setJMenuBar(createMenuBar());
        
        // Set size and center
        setSize(1000, 700);
        setLocationRelativeTo(null);
    }
    
    private JMenuBar createMenuBar() {
        JMenuBar menuBar = new JMenuBar();
        
        // File menu
        JMenu fileMenu = new JMenu("File");
        JMenuItem exitItem = new JMenuItem("Exit");
        exitItem.addActionListener(e -> System.exit(0));
        fileMenu.add(exitItem);
        
        // Help menu
        JMenu helpMenu = new JMenu("Help");
        JMenuItem aboutItem = new JMenuItem("About");
        aboutItem.addActionListener(e -> showAboutDialog());
        helpMenu.add(aboutItem);
        
        menuBar.add(fileMenu);
        menuBar.add(helpMenu);
        
        return menuBar;
    }
    
    private JPanel createItemsPanel() {
        JPanel panel = new JPanel(new BorderLayout());
        
        // Input form
        JPanel inputPanel = new JPanel(new GridBagLayout());
        inputPanel.setBorder(BorderFactory.createTitledBorder("Add New Item"));
        GridBagConstraints gbc = new GridBagConstraints();
        gbc.insets = new Insets(5, 5, 5, 5);
        
        // Title
        gbc.gridx = 0; gbc.gridy = 0;
        inputPanel.add(new JLabel("Title:"), gbc);
        gbc.gridx = 1;
        titleField = new JTextField(20);
        inputPanel.add(titleField, gbc);
        
        // Author
        gbc.gridx = 0; gbc.gridy = 1;
        inputPanel.add(new JLabel("Author:"), gbc);
        gbc.gridx = 1;
        authorField = new JTextField(20);
        inputPanel.add(authorField, gbc);
        
        // ISBN
        gbc.gridx = 0; gbc.gridy = 2;
        inputPanel.add(new JLabel("ISBN:"), gbc);
        gbc.gridx = 1;
        isbnField = new JTextField(20);
        inputPanel.add(isbnField, gbc);
        
        // Category
        gbc.gridx = 0; gbc.gridy = 3;
        inputPanel.add(new JLabel("Category:"), gbc);
        gbc.gridx = 1;
        categoryComboBox = new JComboBox<>(new String[]{"Book", "DVD", "Magazine"});
        inputPanel.add(categoryComboBox, gbc);
        
        // Buttons
        JPanel buttonPanel = new JPanel(new FlowLayout());
        JButton addButton = new JButton("Add Item");
        JButton clearButton = new JButton("Clear");
        
        addButton.addActionListener(e -> addNewItem());
        clearButton.addActionListener(e -> clearItemForm());
        
        buttonPanel.add(addButton);
        buttonPanel.add(clearButton);
        
        gbc.gridx = 0; gbc.gridy = 4; gbc.gridwidth = 2;
        inputPanel.add(buttonPanel, gbc);
        
        // Items table
        String[] columnNames = {"ID", "Title", "Author/Director", "Category", "Available"};
        itemsTableModel = new DefaultTableModel(columnNames, 0) {
            @Override
            public boolean isCellEditable(int row, int column) {
                return false;
            }
        };
        
        itemsTable = new JTable(itemsTableModel);
        itemsTable.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
        JScrollPane tableScrollPane = new JScrollPane(itemsTable);
        tableScrollPane.setBorder(BorderFactory.createTitledBorder("Library Items"));
        
        panel.add(inputPanel, BorderLayout.NORTH);
        panel.add(tableScrollPane, BorderLayout.CENTER);
        
        return panel;
    }
    
    private JPanel createUsersPanel() {
        JPanel panel = new JPanel(new BorderLayout());
        
        // User input form
        JPanel inputPanel = new JPanel(new GridBagLayout());
        inputPanel.setBorder(BorderFactory.createTitledBorder("Register New User"));
        GridBagConstraints gbc = new GridBagConstraints();
        gbc.insets = new Insets(5, 5, 5, 5);
        
        // User ID
        gbc.gridx = 0; gbc.gridy = 0;
        inputPanel.add(new JLabel("User ID:"), gbc);
        gbc.gridx = 1;
        userIdField = new JTextField(20);
        inputPanel.add(userIdField, gbc);
        
        // Name
        gbc.gridx = 0; gbc.gridy = 1;
        inputPanel.add(new JLabel("Name:"), gbc);
        gbc.gridx = 1;
        userNameField = new JTextField(20);
        inputPanel.add(userNameField, gbc);
        
        // Email
        gbc.gridx = 0; gbc.gridy = 2;
        inputPanel.add(new JLabel("Email:"), gbc);
        gbc.gridx = 1;
        userEmailField = new JTextField(20);
        inputPanel.add(userEmailField, gbc);
        
        // Buttons
        JPanel buttonPanel = new JPanel(new FlowLayout());
        JButton registerButton = new JButton("Register User");
        JButton clearButton = new JButton("Clear");
        
        registerButton.addActionListener(e -> registerNewUser());
        clearButton.addActionListener(e -> clearUserForm());
        
        buttonPanel.add(registerButton);
        buttonPanel.add(clearButton);
        
        gbc.gridx = 0; gbc.gridy = 3; gbc.gridwidth = 2;
        inputPanel.add(buttonPanel, gbc);
        
        // Users table
        String[] columnNames = {"User ID", "Name", "Email", "Borrowed Items"};
        usersTableModel = new DefaultTableModel(columnNames, 0) {
            @Override
            public boolean isCellEditable(int row, int column) {
                return false;
            }
        };
        
        usersTable = new JTable(usersTableModel);
        JScrollPane tableScrollPane = new JScrollPane(usersTable);
        tableScrollPane.setBorder(BorderFactory.createTitledBorder("Registered Users"));
        
        panel.add(inputPanel, BorderLayout.NORTH);
        panel.add(tableScrollPane, BorderLayout.CENTER);
        
        return panel;
    }
    
    private JPanel createBorrowReturnPanel() {
        JPanel panel = new JPanel(new BorderLayout());
        
        // Search panel
        JPanel searchPanel = new JPanel(new FlowLayout());
        searchPanel.setBorder(BorderFactory.createTitledBorder("Search Items"));
        
        searchField = new JTextField(20);
        JButton searchButton = new JButton("Search");
        JButton showAllButton = new JButton("Show All");
        
        searchButton.addActionListener(e -> searchItems());
        showAllButton.addActionListener(e -> refreshItemsTable());
        
        searchPanel.add(new JLabel("Search:"));
        searchPanel.add(searchField);
        searchPanel.add(searchButton);
        searchPanel.add(showAllButton);
        
        // Action panel
        JPanel actionPanel = new JPanel(new FlowLayout());
        actionPanel.setBorder(BorderFactory.createTitledBorder("Actions"));
        
        JButton borrowButton = new JButton("Borrow Selected Item");
        JButton returnButton = new JButton("Return Selected Item");
        JButton showStatsButton = new JButton("Show Statistics");
        
        borrowButton.addActionListener(e -> borrowSelectedItem());
        returnButton.addActionListener(e -> returnSelectedItem());
        showStatsButton.addActionListener(e -> showLibraryStatistics());
        
        actionPanel.add(borrowButton);
        actionPanel.add(returnButton);
        actionPanel.add(showStatsButton);
        
        // Output area
        outputArea = new JTextArea(10, 50);
        outputArea.setEditable(false);
        outputArea.setFont(new Font(Font.MONOSPACED, Font.PLAIN, 12));
        JScrollPane outputScrollPane = new JScrollPane(outputArea);
        outputScrollPane.setBorder(BorderFactory.createTitledBorder("System Output"));
        
        JPanel topPanel = new JPanel(new BorderLayout());
        topPanel.add(searchPanel, BorderLayout.NORTH);
        topPanel.add(actionPanel, BorderLayout.CENTER);
        
        panel.add(topPanel, BorderLayout.NORTH);
        panel.add(outputScrollPane, BorderLayout.CENTER);
        
        return panel;
    }
    
    private JPanel createReportsPanel() {
        JPanel panel = new JPanel(new BorderLayout());
        
        // Report buttons
        JPanel buttonPanel = new JPanel(new GridLayout(2, 2, 10, 10));
        buttonPanel.setBorder(BorderFactory.createTitledBorder("Generate Reports"));
        
        JButton usageReportButton = new JButton("Library Usage Report");
        JButton inventoryReportButton = new JButton("Inventory Report");
        JButton userActivityButton = new JButton("User Activity Report");
        JButton statisticsButton = new JButton("Overall Statistics");
        
        usageReportButton.addActionListener(e -> generateUsageReport());
        inventoryReportButton.addActionListener(e -> generateInventoryReport());
        userActivityButton.addActionListener(e -> generateUserActivityReport());
        statisticsButton.addActionListener(e -> displayOverallStatistics());
        
        buttonPanel.add(usageReportButton);
        buttonPanel.add(inventoryReportButton);
        buttonPanel.add(userActivityButton);
        buttonPanel.add(statisticsButton);
        
        // Report output area
        JTextArea reportArea = new JTextArea();
        reportArea.setEditable(false);
        reportArea.setFont(new Font(Font.MONOSPACED, Font.PLAIN, 12));
        JScrollPane reportScrollPane = new JScrollPane(reportArea);
        reportScrollPane.setBorder(BorderFactory.createTitledBorder("Report Output"));
        
        panel.add(buttonPanel, BorderLayout.NORTH);
        panel.add(reportScrollPane, BorderLayout.CENTER);
        
        return panel;
    }
    
    // Event handlers
    private void addNewItem() {
        try {
            String title = titleField.getText().trim();
            String author = authorField.getText().trim();
            String isbn = isbnField.getText().trim();
            String category = (String) categoryComboBox.getSelectedItem();
            
            if (title.isEmpty()) {
                JOptionPane.showMessageDialog(this, "Title is required!", "Error", JOptionPane.ERROR_MESSAGE);
                return;
            }
            
            LibraryItem item = null;
            switch (category) {
                case "Book":
                    if (author.isEmpty() || isbn.isEmpty()) {
                        JOptionPane.showMessageDialog(this, "Author and ISBN are required for books!", 
                                                    "Error", JOptionPane.ERROR_MESSAGE);
                        return;
                    }
                    item = new Book(title, title, author, isbn, 200); // Default 200 pages
                    break;
                case "DVD":
                    item = new DVD(title, title, author.isEmpty() ? "Unknown" : author, 120, "General");
                    break;
                case "Magazine":
                    item = new Magazine(title, title, author.isEmpty() ? "Unknown" : author, 1, "2024");
                    break;
            }
            
            if (item != null) {
                database.addItem(item);
                refreshItemsTable();
                clearItemForm();
                appendToOutput("✓ Item added successfully: " + title);
            }
            
        } catch (Exception e) {
            JOptionPane.showMessageDialog(this, "Error adding item: " + e.getMessage(), 
                                        "Error", JOptionPane.ERROR_MESSAGE);
        }
    }
    
    private void registerNewUser() {
        try {
            String userId = userIdField.getText().trim();
            String name = userNameField.getText().trim();
            String email = userEmailField.getText().trim();
            
            if (userId.isEmpty() || name.isEmpty() || email.isEmpty()) {
                JOptionPane.showMessageDialog(this, "All fields are required!", 
                                            "Error", JOptionPane.ERROR_MESSAGE);
                return;
            }
            
            User user = new User(userId, name, email);
            database.registerUser(user);
            refreshUsersTable();
            clearUserForm();
            appendToOutput("✓ User registered successfully: " + name);
            
        } catch (Exception e) {
            JOptionPane.showMessageDialog(this, "Error registering user: " + e.getMessage(), 
                                        "Error", JOptionPane.ERROR_MESSAGE);
        }
    }
    
    private void borrowSelectedItem() {
        int selectedRow = itemsTable.getSelectedRow();
        if (selectedRow == -1) {
            JOptionPane.showMessageDialog(this, "Please select an item to borrow", 
                                        "No Selection", JOptionPane.WARNING_MESSAGE);
            return;
        }
        
        String userId = JOptionPane.showInputDialog(this, "Enter User ID:");
        if (userId == null || userId.trim().isEmpty()) {
            return;
        }
        
        try {
            String itemId = (String) itemsTableModel.getValueAt(selectedRow, 0);
            // Simulate borrow process
            appendToOutput("Processing borrow request for User: " + userId + ", Item: " + itemId);
            // Here you would call your library service methods
            
        } catch (Exception e) {
            appendToOutput("Error: " + e.getMessage());
        }
    }
    
    private void searchItems() {
        String keyword = searchField.getText().trim();
        if (keyword.isEmpty()) {
            refreshItemsTable();
            return;
        }
        
        List<LibraryItem> results = database.searchItems(keyword);
        updateItemsTable(results);
        appendToOutput("Search completed. Found " + results.size() + " items matching: " + keyword);
    }
    
    // Helper methods
    private void clearItemForm() {
        titleField.setText("");
        authorField.setText("");
        isbnField.setText("");
        categoryComboBox.setSelectedIndex(0);
    }
    
    private void clearUserForm() {
        userIdField.setText("");
        userNameField.setText("");
        userEmailField.setText("");
    }
    
    private void appendToOutput(String message) {
        outputArea.append(message + "\n");
        outputArea.setCaretPosition(outputArea.getDocument().getLength());
    }
    
    private void refreshItemsTable() {
        updateItemsTable(database.getAllItems());
    }
    
    private void updateItemsTable(List<LibraryItem> items) {
        itemsTableModel.setRowCount(0);
        for (LibraryItem item : items) {
            Object[] row = {
                item.getId(),
                item.getTitle(),
                getAuthorOrDirector(item),
                item.getCategory(),
                item.isAvailable() ? "Yes" : "No"
            };
            itemsTableModel.addRow(row);
        }
    }
    
    private void refreshUsersTable() {
        usersTableModel.setRowCount(0);
        for (User user : database.getAllUsers()) {
            Object[] row = {
                user.getUserId(),
                user.getName(),
                user.getEmail(),
                user.getBorrowedItems().size()
            };
            usersTableModel.addRow(row);
        }
    }
    
    private String getAuthorOrDirector(LibraryItem item) {
        if (item instanceof Book) {
            return ((Book) item).getAuthor();
        } else if (item instanceof DVD) {
            return ((DVD) item).getDirector();
        } else if (item instanceof Magazine) {
            return ((Magazine) item).getPublisher();
        }
        return "Unknown";
    }
    
    private void showAboutDialog() {
        String message = "Library Management System\n" +
                        "Version 1.0\n" +
                        "Built with Java Swing\n" +
                        "Demonstrating OOP Concepts";
        JOptionPane.showMessageDialog(this, message, "About", JOptionPane.INFORMATION_MESSAGE);
    }
    
    private void loadSampleData() {
        // Load some sample data for demonstration
        try {
            Book book1 = new Book("B001", "Java Programming", "John Doe", "1234567890", 300);
            Book book2 = new Book("B002", "Data Structures", "Jane Smith", "0987654321", 250);
            DVD dvd1 = new DVD("D001", "The Matrix", "Wachowski Sisters", 136, "Sci-Fi");
            
            database.addItem(book1);
            database.addItem(book2);
            database.addItem(dvd1);
            
            User user1 = new User("U001", "Alice Johnson", "alice@email.com");
            User user2 = new User("U002", "Bob Wilson", "bob@email.com");
            
            database.registerUser(user1);
            database.registerUser(user2);
            
            refreshItemsTable();
            refreshUsersTable();
            
            appendToOutput("Sample data loaded successfully");
            
        } catch (Exception e) {
            appendToOutput("Error loading sample data: " + e.getMessage());
        }
    }
    
    // Report generation methods
    private void generateUsageReport() {
        LibraryUsageReport report = new LibraryUsageReport("System Admin", 
                                                          database.getAllItems(), 
                                                          database.getAllUsers());
        
        // Capture console output for display
        java.io.ByteArrayOutputStream baos = new java.io.ByteArrayOutputStream();
        java.io.PrintStream ps = new java.io
